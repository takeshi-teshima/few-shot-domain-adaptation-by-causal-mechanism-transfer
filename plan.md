## それぞれのレベルのAPIが担う関心事の例
- 実験スクリプト
  - 応用レベルAPIの呼び出し
  - 実験設定のパラメータ等の指定
  - エントリーポイント
  - データの読み出し・前処理
- 応用レベルAPI
  - ハイパーパラメータ選択の仕組み（BO，Grid search，...）
  - 結果保存の仕組み
  - 手法のいくつかの工夫の組合せ方(ablation)
- 手法レベルAPI
  - 学習のロジック
  - 推論のロジック
  - 評価器を受け取っての評価
  - 異なる言語のプログラムを内部的に走らせる等
- 基本手法レベルAPI
  - 学習などのロジックや詳細な計算

## 基本構成案
- 基本構成単位：ロジックとAPI
  - api_ICML15.py   <- 応用レベルAPI．特定のモデルや学習方法の組み合わせなどを呼び出したりするために使う．ハイパーパラメータ選択等＋結果の保存の仕方等はこのレイヤーに落ちる．手法名が付くくらいの粒度．
  - api.py          <- 応用レベルAPI．汎用的に何かコマンドとして使いたいようなときに使う．
  - algorithm/
    - api.py        <- 手法レベルAPI．学習〜推論〜評価などを行うためのAPIを提供する．上のapi.pyなどから呼び出される．
    - 手法のロジックのファイル諸々

- 既存手法のコードを取り込む場合
  - api.py          <- 応用レベルAPI．自分の実験に合わせて色々書く．
  - algorithm/
    - api.py        <- 手法レベルAPI．既存手法のロジックから色々な情報を抽出して応用レベルAPIで記録できるように露出したり，応用レベルAPIで使いたいメソッドになるように合わせたりする．異なる言語のスクリプトを動かすために使っても良い．
    - 既存手法の既存コードのロジックファイル諸々


## メモ
- APIをいくつか作成
  - これがSacredや単なるGrid-search + プリントなどの処理を受け持つ
    - 基本構成は，実験パラメータ受け取り→インスタンス生成
    - アルゴリズム1(データを与える)
      - 走りながら記録
    - 結果を取得して保存
    - 評価して結果を保存
  - 手法としてアルゴリズム1の構成もまとめる
    - API
    - mechanism_transferなども実行
  - 階層構造の各段階にそれぞれテンプレ構造を入れる
  - Augmenterは1つのファイルにする
  - utilとしてGlowなども持つ
  - Hyper-parameterは実験スクリプト側で持つ．1回分の学習〜評価までだけをモデルが担う．

- 原則
  - BOやGrid-searchなど諸々を抽象化して1つのAPIでまとめるのは無理だと諦める
  - 例えばMLFlow独自の記録操作やOptuna独自の記録やらそれらの組合せやら対応できない状況や新たに記録したいものが現れる状況は無数にある．
  - ループ中で結果を記録するか，それとも単にCVした結果の学習済みモデルだけ返ってこればよいか，などによっても全然違う．
  - これらを統一的に扱うことは諦めて「APIレイヤー」を加える．このレイヤーでは，例えば「特定の論文の特定の実験において用いる学習・検証用API」ぐらいの粒度のメソッドを置く．
  - 同様に「コード公開時のデモ用のAPI」などを作ることもできる．例えばそこでは結果を仔細に記録せずにざっくりした結果だけ返す処理をするなど．
  - このAPIは例えば実験者ごとに作れば良いので，異なる手法を比較するような場合にもここのAPIを揃えることによって統一的な実験スクリプトを書くことが可能になったりする．
  - APIレイヤーのコードのファイル名も，実験名や論文のタイトルを付けるくらいの粒度感で良い．
  - モデル側ではこのAPIを構築するが，


- プロジェクト全体の構造：「手法」や「実験のループ〜記録」などのそれぞれの構成単位において，それぞれapi.pyを必ず持ちここでインターフェイスをさせる．api.pyは異なる保存方法や異なる実験目的などが出てきたときには毎度新しく作る．
- 手法ディレクトリ/手法をまとめたディレクトリ
